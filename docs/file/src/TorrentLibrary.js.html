<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/TorrentLibrary.js | torrent-files-library</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Scan directories to build a library of media files (movie or tv show) that follows torrent naming conventions"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="torrent-files-library"><meta property="twitter:description" content="Scan directories to build a library of media files (movie or tv show) that follows torrent naming conventions"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/jy95/torrent-files-library.git"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/TorrentLibrary.js~TorrentLibrary.html">TorrentLibrary</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="Promise http://bluebirdjs.com/docs/api-reference">*</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="Promise http://bluebirdjs.com/docs/api-reference">*</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#docs-events">docs/events</a><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Events#addNewPath">Events#addNewPath</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Events#error_in_function">Events#error_in_function</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Events#missing_parameter">Events#missing_parameter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Events#removeOldFiles">Events#removeOldFiles</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Events#scan">Events#scan</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#docs-types">docs/types</a><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-StorageVar">StorageVar</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-StoreVar">StoreVar</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-TPN">TPN</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-TPN_Extended">TPN_Extended</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-additionalProperties">additionalProperties</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-numberExpressionObject">numberExpressionObject</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-numberSearchSyntax">numberSearchSyntax</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-searchParameters">searchParameters</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#filters">filters</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-excludeDefaultBooleanProperties">excludeDefaultBooleanProperties</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-filterByBoolean">filterByBoolean</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-filterDefaultBooleanProperties">filterDefaultBooleanProperties</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-convertToValidExpression">convertToValidExpression</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-excludeDefaultNumberProperties">excludeDefaultNumberProperties</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-filterByNumber">filterByNumber</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-filterDefaultNumberProperties">filterDefaultNumberProperties</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-excludeDefaultStringProperties">excludeDefaultStringProperties</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-filterByString">filterByString</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-filterDefaultStringProperties">filterDefaultStringProperties</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/TorrentLibrary.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/**
 * module for exploring directories
 * @see {@link https://nspragg.github.io/filehound/}
 */
import FileHound from &apos;filehound&apos;;

/**
 * Access method from module fs (node) with constants
 * @see {@link https://nodejs.org/api/fs.html#fs_fs_access_path_mode_callback}
 * @see {@link https://nodejs.org/api/fs.html#fs_fs_constants_1}
 */
import {
  access,
  constants as FsConstants,
} from &apos;fs&apos;;

/**
 * Basename and normalize methods from module path (node)
 * @see {@link https://nodejs.org/api/path.html#path_path_basename_path_ext}
 * @see {@link https://nodejs.org/api/path.html#path_path_normalize_path}
 */
import { basename, normalize } from &apos;path&apos;;


/**
 * uniq and difference methods from Lodash
 * @see {@link https://lodash.com/docs/4.17.4#uniq}
 * @see {@link https://lodash.com/docs/4.17.4#difference}
 * @see {@link https://lodash.com/docs/4.17.4#partition}
 * @see {@link https://lodash.com/docs/4.17.4#cloneDeep}
 */
import { uniq, difference, partition, cloneDeep } from &apos;lodash&apos;;

/**
 * A promise object provided by the bluebird promise library.
 * @external Promise http://bluebirdjs.com/docs/api-reference
 */
import PromiseLib from &apos;bluebird&apos;;

/**
 * List of video file extensions
 * @see {@link https://github.com/sindresorhus/video-extensions}
 */
import videosExtension from &apos;video-extensions&apos;;

/**
 * Parser for media files name
 * @see {@link https://github.com/clement-escolano/parse-torrent-title}
 */
import { parse as nameParser } from &apos;parse-torrent-title&apos;;

/**
 * @external EventEmitter https://nodejs.org/api/events.html#events_class_eventemitter
 */
import EventEmitter from &apos;events&apos;;

/**
 * Boolean properties filter
 */
import {
  filterDefaultBooleanProperties,
  filterByBoolean,
  excludeDefaultBooleanProperties,
} from &apos;./filters/filterBooleanProperty&apos;;

/**
 * Number properties filter
 */
import {
  convertToValidExpression,
  excludeDefaultNumberProperties,
  filterDefaultNumberProperties,
  filterByNumber,
} from &apos;./filters/filterNumberProperty&apos;;

/**
 * String properties filter
 */
import {
  excludeDefaultStringProperties,
  filterDefaultStringProperties,
  filterByString,
} from &apos;./filters/filterStringProperty&apos;;

/**
 * check if an object has these properties and they are not undefined
 * @param {Object} obj The object
 * @param {Array} properties The properties array
 * @return {boolean} The result
 */
function checkProperties(obj, properties) {
  return properties.every(x =&gt; x in obj &amp;&amp; obj[x]);
}

/**
 * rejected promise when someone doesn&apos;t provide
 * @return {Promise} The rejected promise
 */
function missingParam() {
  return new PromiseLib(((resolve, reject) =&gt; {
    reject(new Error(&apos;Missing parameter&apos;));
  }));
}

/**
 * Bluebird seems to have an issue with fs.access - Workaround function
 * @private
 * @param {string} path a path
 * @returns {Promise} an Promise object resolved or rejected
 * @see {@link https://github.com/petkaantonov/bluebird/issues/1442}
 */
function promisifiedAccess(path) {
  return new PromiseLib(((resolve, reject) =&gt; {
    access(path, FsConstants.F_OK | FsConstants.R_OK, (err) =&gt; {
      if (err) reject(err);
      resolve();
    });
  }));
}

/**
 * Class representing the TorrentLibrary
 */
export default class TorrentLibrary extends EventEmitter {
  /**
     * constant for movie category
     * @since 0.0.0
     * @type {string}
     * @static
     */
  static get MOVIES_TYPE() {
    return &apos;MOVIES&apos;;
  }

  /**
     * constant for tv series category
     * @type {string}
     * @since 0.0.0
     * @static
     */
  static get TV_SERIES_TYPE() {
    return &apos;TV_SERIES&apos;;
  }

  /**
     * Create a TorrentLibrary
     * @since 1.0.4
     * @param {Object} [config] - the config object
     * @param {(String)} [config.defaultPath=process.cwd()] - the default path
     * @param {(String[])} [config.paths=[]] - the paths where we are looking the media files
     * @param {(Map&lt;string,string&gt;)} [config.allFilesWithCategory=new Map()] - Mapping filepath =&gt; category
     * @param {(Set&lt;TPN_Extended&gt;)} [config.movies=new Set()] - the movies files
     * @param {(Map&lt;string, Set&lt;TPN_Extended&gt;&gt;)} [config.series=new Map()] - the serie files
     */
  constructor({
    defaultPath = process.cwd()
    /* istanbul ignore next: tired of writing tests */,
    paths = [] /* istanbul ignore next: tired of writing tests */,
    allFilesWithCategory = new Map()
    /* istanbul ignore next: tired of writing tests */,
    movies = new Set() /* istanbul ignore next: tired of writing tests */,
    series = new Map() /* istanbul ignore next: tired of writing tests */,
  } = {} /* istanbul ignore next: tired of writing tests */) {
    super();
    /**
         * just an easy way to scan the current directory path, if not other paths provided
         * @type  {string}
         * @since 0.0.0
         */
    this.defaultPath = defaultPath;
    /**
         * the paths where we are looking the media files
         * @type {String[]}
         * @since 0.0.0
         * @example
         * // after have added some paths ...
         * [ &quot;D:\somePath&quot;, &quot;D:\anotherPath&quot; ]
         */
    this.paths = paths;
    /**
         * The variable where we store all kind of media files found in paths
         * @type {StoreVar}
         * @since 0.0.0
         */
    this.stores = new Map([
      [TorrentLibrary.MOVIES_TYPE, movies],
      [TorrentLibrary.TV_SERIES_TYPE, series],
    ]);
    /**
         * Mapping filepath =&gt; category
         * @type {Map&lt;string,string&gt;}
         * @since 0.0.0
         * @example
         * { &quot;D:\somePath\Captain Russia The Summer Soldier (2014) 1080p BrRip x264.MKV&quot; =&gt; TorrentLibrary.MOVIES_TYPE }
         */
    this.categoryForFile = allFilesWithCategory;
    /**
         * Private method for adding new files
         * @private
         * @returns {Promise} an resolved or reject promise
         * @param {string[]} files An array of filePath
         */
    this.addNewFiles = function addNewFiles(files) {
      const that = this;

      return new PromiseLib((resolve, reject) =&gt; {
        try {
          // find the new files to be added
          const alreadyFoundFiles = [...that.categoryForFile.keys()];
          const newFiles = difference(files, alreadyFoundFiles);

          // temp var for new files before adding them to stores var
          const moviesSet = new Set();
          const tvSeriesSet = new Set();

          // get previous result of stores var
          let newMovies = that.allMovies;
          const newTvSeries = that.allTvSeries;

          // process each file
          for (const file of newFiles) {
            // get data from nameParser lib
            // what we need is only the basename, not the full path
            const jsonFile = nameParser(basename(file));
            // extend this object in order to be used by this library
            Object.assign(jsonFile, { filePath: file });
            // find out which type of this file
            // if it has not undefined properties (season and episode) =&gt; TV_SERIES , otherwise MOVIE
            const fileCategory =
                (checkProperties(jsonFile, [&apos;season&apos;, &apos;episode&apos;]))
                  ? TorrentLibrary.TV_SERIES_TYPE : TorrentLibrary.MOVIES_TYPE;
            // add it in found files
            that.categoryForFile.set(file, fileCategory);
            // also in temp var
            if (fileCategory !== TorrentLibrary.TV_SERIES_TYPE) {
              moviesSet.add(jsonFile);
            } else {
              tvSeriesSet.add(jsonFile);
            }
          }

          // add the movies into newMovies
          newMovies = new Set([...newMovies, ...moviesSet]);

          // add the tv series into newTvSeries
          // First step : find all the series not in newTvSeries and add them to newTvSeries
          difference(
            uniq([...tvSeriesSet].map(tvSeries =&gt; tvSeries.title)),
            ...newTvSeries.keys(),
          ).forEach((tvSeriesToInsert) =&gt; {
            newTvSeries.set(tvSeriesToInsert, new Set());
          });

          // Second step : add the new files into the correct tvSeries Set
          uniq([...tvSeriesSet].map(tvSeries =&gt; tvSeries.title))
            .forEach((tvSerie) =&gt; {
            // get the current set for this tvSerie
              const currentTvSerie = newTvSeries.get(tvSerie);

              // find all the episodes in the new one for this serie
              const episodes = [...tvSeriesSet]
                .filter(episode =&gt; episode.title === tvSerie);

              // add them and updates newTvSeries
              newTvSeries.set(
                tvSerie,
                new Set([...currentTvSerie, ...episodes]),
              );
            });

          // updates the stores var
          that.stores.set(TorrentLibrary.MOVIES_TYPE, newMovies);
          that.stores.set(TorrentLibrary.TV_SERIES_TYPE, newTvSeries);
          resolve();
        } catch (err) {
          /* istanbul ignore next */
          reject(err);
        }
      });
    };
  }

  /**
     * Provides the array of files extensions considered to be media extensions
     * @return {string[]} array of files extensions
     * @since 0.0.0
     * @example
     * // Returns [..., &apos;webm&apos;, &apos;wmv&apos;]
     * TorrentLibrary.listVideosExtension()
     */
  static listVideosExtension() {
    return videosExtension;
  }

  /**
     * Add the path(s) to be analyzed by the library if they exist and are readable
     * @param {...string} paths - A or more path(s)
     * @since 0.0.0
     * @example
     * // return resolved Promise &quot;All paths were added!&quot;
     * TorrentLibraryInstance.addNewPath(&quot;C:\Users\jy95\Desktop\New folder&quot;,&quot;C:\Users\jy95\Desktop\New folder2&quot;);
     * @return {Promise}  On success the promise will be resolved with &quot;All paths were added!&quot;&lt;br&gt;
     * On error the promise will be rejected with an Error object &quot;Missing parameter&quot; if the argument is missing&lt;br&gt;
     * or an Error object from fs &lt;br&gt;
     * @emits Events#missing_parameter
     * @emits Events#error_in_function
     * @emits Events#addNewPath
     */
  addNewPath(...paths) {
    // the user should provide us at lest a path
    if (paths.length === 0) {
      this.emit(&apos;missing_parameter&apos;, {
        functionName: &apos;addNewPath&apos;,
      });
      return missingParam();
    }

    const that = this;
    return new PromiseLib(((resolve, reject) =&gt; {
      PromiseLib.map(paths, path =&gt; promisifiedAccess(path)).then(() =&gt; {
        // keep only unique paths
        // use normalize for cross platform&apos;s code
        that.paths = uniq([...that.paths, ...paths.map(normalize)]);
        that.emit(&apos;addNewPath&apos;, { paths: that.paths });
        resolve(&apos;All paths were added!&apos;);
      }).catch((e) =&gt; {
        that.emit(&apos;error_in_function&apos;, {
          functionName: &apos;addNewPath&apos;,
          error: e.message,
        });
        reject(e);
      });
    }));
  }

  /**
     * Tell us if the user has provided us paths
     * @since 0.0.0
     * @returns {boolean} Has user provided us paths ?
     * @example
     * TorrentLibraryInstance.addNewPath(&quot;C:\Users\jy95\Desktop\New folder&quot;,&quot;C:\Users\jy95\Desktop\New folder2&quot;);
     * TorrentLibraryInstance.hasPathsProvidedByUser() // TRUE
     */
  hasPathsProvidedByUser() {
    return this.paths.length !== 0;
  }

  /**
     * Scans the paths in search for new files to be added inside this lib
     * @since 0.0.0
     * @return {Promise}  On success the promise will be resolved with &quot;Scanning completed&quot;&lt;br&gt;
     * On error the promise will be rejected with an Error object from sub modules&lt;br&gt;
     * @emits Events#scan
     * @emits Events#error_in_function
     */
  scan() {
    const foundFiles = FileHound.create()
      .paths((this.paths.length === 0) ? this.defaultPath : this.paths)
      .ext(videosExtension)
      .find();
    const that = this;

    return new PromiseLib((resolve, reject) =&gt; {
      foundFiles
        .then(files =&gt; that.addNewFiles(files)).then(() =&gt; {
          that.emit(&apos;scan&apos;, { files: foundFiles });
          resolve(&apos;Scanning completed&apos;);
        }).catch(/* istanbul ignore next */ (err) =&gt; {
        /* istanbul ignore next */
          that.emit(&apos;error_in_function&apos;, {
            functionName: &apos;scan&apos;,
            error: err.message,
          });
          /* istanbul ignore next */
          reject(err);
        });
    });
  }


  /**
     * Removes files stored in this library
     * @param {...string} files An array of filePath (for example the keys of allFilesWithCategory)
     * @since 1.0.3
     * @return {Promise} an resolved or rejected promise&lt;br&gt;
     * On success, the resolve will contain an message and the removed filePaths&lt;br&gt;
     * On error the promise will be rejected with an Error object from sub modules&lt;br&gt;
     * @example
     * // with multiples files
     * TorrentLibraryInstance.removeOldFiles(
     *    &quot;D:\somePath\Captain Russia The Summer Soldier (2014) 1080p BrRip x264.MKV&quot;,
     *    &quot;D:\\workspaceNodeJs\\torrent-files-library\\test\\folder1\\The.Blacklist.S04E21.FRENCH.WEBRip.XviD.avi&quot;
     * )
     * @emits Events#removeOldFiles
     * @emits Events#error_in_function
     */
  removeOldFiles(...files) {
    const that = this;
    return new PromiseLib((resolve, reject) =&gt; {
      try {
        // get the data to handle this case
        // in the first group, we got all the tv series files and in the second, the movies
        const processData = partition(files, file =&gt;
          that.categoryForFile.get(file) === TorrentLibrary.TV_SERIES_TYPE);

        // for movies, just an easy removal
        that.stores.set(
          TorrentLibrary.MOVIES_TYPE,
          new Set([...that.allMovies]
            .filter(movie =&gt; !(processData[1].includes(movie.filePath)))),
        );

        // for the tv-series, a bit more complicated
        // first step : find the unique tv series of these files
        const tvSeriesShows = uniq(processData[0]
          .map(file =&gt; nameParser(basename(file)).title));

        // second step : foreach each series in tvSeriesShows
        const newTvSeriesMap = that.allTvSeries;

        for (const serie of tvSeriesShows) {
          // get the set for this serie
          const filteredSet = new Set([...newTvSeriesMap.get(serie)]
            .filter(episode =&gt;
              !(processData[0].includes(episode.filePath))));
          // if the filtered set is empty =&gt; no more episodes for this series
          if (filteredSet.size === 0) {
            newTvSeriesMap.delete(serie);
          } else newTvSeriesMap.set(serie, filteredSet);
        }

        // save the updated map
        that.stores.set(TorrentLibrary.TV_SERIES_TYPE, newTvSeriesMap);

        // remove the mapping
        files.forEach((file) =&gt; {
          that.categoryForFile.delete(file);
        });
        that.emit(&apos;removeOldFiles&apos;, { files });
        resolve({
          message: &apos;The files have been deleted from the library&apos;,
          files,
        });
        /* istanbul ignore next */
      } catch (err) {
        /* istanbul ignore next */
        that.emit(&apos;error_in_function&apos;, {
          functionName: &apos;removeOldFiles&apos;,
          error: err.message,
        });
        /* istanbul ignore next */
        reject(err);
      }
    });
  }

  /**
     * Getter for all found movies
     * @since 0.0.0
     * @type {Set&lt;TPN_Extended&gt;}
     * @example
     * // an JSON stringified example of this method
     * [
     *  {
     *   &quot;year&quot;:2012,
     *   &quot;source&quot;:&quot;dvdrip&quot;,
     *   &quot;codec&quot;:&quot;xvid&quot;,
     *   &quot;group&quot;:&quot;-www.zone-telechargement.ws.avi&quot;,
     *   &quot;container&quot;:&quot;avi&quot;,
     *   &quot;language&quot;:&quot;truefrench&quot;,
     *   &quot;title&quot;:&quot;Bad Ass&quot;,
     *   &quot;filePath&quot;:&quot;D:\\workspaceNodeJs\\torrent-files-library\\test\\folder1\\Bad.Ass.2012.LiMiTED.TRUEFRENCH.DVDRiP.XviD-www.zone-telechargement.ws.avi&quot;
     *  }
     * ]
     */
  get allMovies() {
    return cloneDeep(this.stores.get(TorrentLibrary.MOVIES_TYPE));
  }

  /**
     * Getter for all found tv-series
     * @since 0.0.0
     * @type {Map&lt;string, Set&lt;TPN_Extended&gt;&gt;}
     * @example
     * // an JSON stringified example of this method
     * {
   * &quot;The Blacklist&quot;:[
   *    {
   *      &quot;season&quot;:4,
   *      &quot;episode&quot;:21,
   *      &quot;source&quot;:&quot;webrip&quot;,
   *      &quot;codec&quot;:&quot;xvid&quot;,
   *      &quot;container&quot;:&quot;avi&quot;,
   *      &quot;language&quot;:&quot;french&quot;,
   *      &quot;title&quot;:&quot;The Blacklist&quot;,
   *      &quot;filePath&quot;:&quot;D:\\workspaceNodeJs\\torrent-files-library\\test\\folder1\\The.Blacklist.S04E21.FRENCH.WEBRip.XviD.avi&quot;
   *   },
   *   {
   *      &quot;season&quot;:4,
   *      &quot;episode&quot;:14,
   *      &quot;source&quot;:&quot;webrip&quot;,
   *      &quot;codec&quot;:&quot;xvid&quot;,
   *      &quot;container&quot;:&quot;avi&quot;,
   *      &quot;language&quot;:&quot;french&quot;,
   *      &quot;title&quot;:&quot;The Blacklist&quot;,
   *      &quot;filePath&quot;:&quot;D:\\workspaceNodeJs\\torrent-files-library\\test\\folder2\\The.Blacklist.S04E14.FRENCH.WEBRip.XviD.avi&quot;
   *   }
   * ]
* }
     */
  get allTvSeries() {
    return cloneDeep(this.stores.get(TorrentLibrary.TV_SERIES_TYPE));
  }

  /**
     * Getter for the mapping between filepaths and category
     * @type {Map&lt;string,string&gt;}
     * @since 0.0.0
     * @example
     * { &quot;D:\somePath\Captain Russia The Summer Soldier (2014) 1080p BrRip x264.MKV&quot; =&gt; TorrentLibrary.MOVIES_TYPE }
     */
  get allFilesWithCategory() {
    return cloneDeep(this.categoryForFile);
  }

  /**
     * Returns an JSON stringified of the current state
     * @since 1.0.3
     * @see {@link https://github.com/jy95/torrent-files-library/tree/master/tests/fixtures/example.json}
     * @return {string} json - the JSON stringified
     */
  toJSON() {
    const tvSeries = this.allTvSeries;
    return `{
    &quot;paths&quot;:${JSON.stringify([...this.paths])},
    &quot;allFilesWithCategory&quot;:${JSON.stringify([...this.allFilesWithCategory])},
    &quot;movies&quot;:${JSON.stringify([...this.allMovies])},
    &quot;tv-series&quot;:${JSON.stringify([...tvSeries].map(serie =&gt;
    // serie[0] contains the title and [1] the wrong JSON ; let fix it
    [serie[0], [...tvSeries.get(serie[0])]]))}
    }`;
  }

  /**
     * Creates an instance of TorrentLibrary
     * @param {Object} [json] - the JSON object of toJSON() string
     * @param {(String[])} json.paths - the paths where we are looking the media files
     * @param {(Array.&lt;Array.&lt;String,String&gt;&gt;)} json.allFilesWithCategory - Mapping filepath =&gt; category
     * @param {(TPN_Extended[])} json.movies - the movies files
     * @param {(Array.&lt;Array.&lt;String,TPN_Extended[]&gt;&gt;)} json.tv-series - the serie files
     * @see {@link https://github.com/jy95/torrent-files-library/tree/master/test/example.json} for an param example
     * @since 1.2.0
     * @return {TorrentLibrary} an TorrentLibrary instance
     * @example
     * // creates an new instance from another one
     *   const createdInstance = TorrentLibrary.createFromJSON(
     *      JSON.parse(libInstance.toJSON()),
     *   );
     */
  static createFromJSON(json) {
    let config = json;
    // transform the param
    /* istanbul ignore else */
    if (json.allFilesWithCategory) {
      config.allFilesWithCategory = new Map(json.allFilesWithCategory);
    }
    /* istanbul ignore else */
    if (json.movies) {
      config.movies = new Set(json.movies);
    }
    /* istanbul ignore else */
    if (json[&apos;tv-series&apos;]) {
      let createdMap = new Map();
      for (let [serieTitle, setSerie] of json[&apos;tv-series&apos;]) {
        createdMap.set(serieTitle, new Set(setSerie));
      }
      config.series = createdMap;
    }
    return new TorrentLibrary(config);
  }

  /**
   * Filter the movies based on search parameters
   * @param {searchParameters} searchParameters - search parameters.
   * @return {Set&lt;TPN_Extended&gt;} the filtered movie set
   * @since 1.3.0
   */
  filterMovies(searchParameters = {
    // boolean properties
    extended: undefined,
    unrated: undefined,
    proper: undefined,
    repack: undefined,
    convert: undefined,
    hardcoded: undefined,
    retail: undefined,
    remastered: undefined,
    // number properties
    season: undefined,
    episode: undefined,
    year: undefined,
    // string properties
    title: undefined,
    resolution: undefined,
    codec: undefined,
    audio: undefined,
    group: undefined,
    region: undefined,
    container: undefined,
    language: undefined,
    source: undefined,
    // new properties
    additionalProperties: [],
  }) {
    // organize search based on field type : boolean - string - number
    // eslint-disable-next-line max-len
    const booleanFieldsSearchMap = filterDefaultBooleanProperties(searchParameters);
    // eslint-disable-next-line max-len
    let leftSearchParameters = excludeDefaultBooleanProperties(searchParameters);

    // eslint-disable-next-line max-len
    const numberFieldsSearchMap = filterDefaultNumberProperties(leftSearchParameters);
    leftSearchParameters = excludeDefaultNumberProperties(leftSearchParameters);

    // eslint-disable-next-line max-len
    const stringFieldsSearchMap = filterDefaultStringProperties(leftSearchParameters);
    leftSearchParameters = excludeDefaultStringProperties(leftSearchParameters);

    let { additionalProperties } = leftSearchParameters;
    // add the optional new properties , optionally provided by user
    /* istanbul ignore else */
    if (additionalProperties !== undefined) {
      additionalProperties
        .filter(newProperty =&gt; newProperty.type === &apos;boolean&apos;)
        .forEach((newProperty) =&gt; {
          booleanFieldsSearchMap.set(newProperty.name, newProperty.value);
        });

      additionalProperties
        .filter(newProperty =&gt; newProperty.type === &apos;number&apos;)
        .forEach((newProperty) =&gt; {
          let expression = convertToValidExpression(newProperty.value);
          /* istanbul ignore else */
          if (expression !== undefined) {
            numberFieldsSearchMap.set(newProperty.name, expression);
          }
        });

      additionalProperties
        .filter(newProperty =&gt; newProperty.type === &apos;string&apos;)
        .forEach((newProperty) =&gt; {
          stringFieldsSearchMap.set(newProperty.name, [...newProperty.value]);
        });
    }

    // apply params based on types
    let result = filterByBoolean(this.allMovies, booleanFieldsSearchMap);
    result = filterByNumber(result, numberFieldsSearchMap);
    result = filterByString(result, stringFieldsSearchMap);
    return result;
  }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.0.4)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
